---
title: 动态规划算法学习——01背包
abbrlink: 58931
date: 2020-04-28 02:17:43
tags:
---

## 前言

本文章主要是为了学习动态规划算法问题，这首先是进行对01背包问题进行学习。01背包问题是DP算法的基础，其他的完全背包都是从此基础上进行演进的。

对于01背包，有一个十分明显的特点：每件物品只可以操作一次，可以选择放与不放。

>题目：有N件物品和一个容量为V的背包，放入第i件物品消耗的容量为Ci，可以获得的价值为Wi，求最大的价值总和。
>
>F[i,v]代表前i件物品放入容量为v的背包可以获得的最大价值。因此可以得到转移方程为`F[i, v] =  max{F[i - 1, v], F[i - 1, v - Ci] + Wi}`
>
>可以得到伪代码：
>
>```
>F[0,0..V] <- 0
>for i <- 1 to N
>	for v <- Ci to V
>		F[i, v] <- max{F[i - 1, v], F[i - 1,v - Ci] + Wi}
>```
>此处建议查看《背包九讲》

## LeetCode416-[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

> 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
> 注意:
>
> 每个数组中的元素不会超过 100
> 数组的大小不会超过 200
> 示例 1:
>
> 输入: [1, 5, 11, 5]
>
> 输出: true
>
> 解释: 数组可以分割成 [1, 5, 5] 和 [11].
>
>
> 示例 2:
>
> 输入: [1, 2, 3, 5]
>
> 输出: false
>
> 解释: 数组不能分割成两个元素和相等的子集.
>

### 思路

1. 这道题的难度在于如何初始化数组。在背包问题中，有容量V，最大价值F，和第i件物品价值Wi与耗费Ci。从题目可以得知，容量V的大小是数组之和sum除于2。而本题中，容量V与价值F是相等的，并且每件物品的价值W和耗费C是相等的。
2. 考虑边界条件：
   1. 当数组大小为0的时候，直接返回false
   2. 当sum/2为奇数的时候，直接返回false

### 代码实现

```java
class Solution{
	public boolean canPartition(int[] nums) {
    // 边界条件1
  	if(nums.length == 0)
      return false;
    
    int sum = 0;	// 根据题目得知最大总和为 100*200=20000，因此使用int即可
    for(int n: nums) {
      sum += n;
    }
    // 边界条件2
    if((sum & 1) == 1)
      return false;
    
    int v = sum / 2;
    int dp = new int[v + 1];	// 初始化背包，开始全部为0
    for( int i = 0; i < nums.length; i++) {	// 遍历所有的物品
      // 从背包的最大容量开始，直到最低容量为当前物品的消耗为止
      for( int j = v; j >= nums[i]; j--) {	
        if(dp[j - nums[i]] + nums[i] > v)	{// 当容量为j时，放入当前物品是否会超出最大价值F 
          // 如果超出了，则取只放入当前物品或者之前的方案中最大的结果
          dp[j] = Math.max(dp[j], nums[i]);	
        } else {
          // 如果没有超出，则取当前组合或者之前方案中最大的结果
          dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
      }
    }
    // 判断最后的结果是否出现价值为最大价值F的结果
    return dp[v] == v;
	}
}
```

### 示例

以[1,5,11,5]为例子，其中子集之和为sum/2=11,所以DP背包大小为11，而且最大值不能超过11。建立图标如下所示：

| 最后一个数 |      |      |      |      |      |      |      |      |      |      |      |                      |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------------------- |
| 5          | 1    | 1    | 1    | 1    | 5    | 6    | 6    | 6    | 6    | 10   | 11   | 只需要判断这个数即可 |
| 11         | 1    | 1    | 1    | 1    | 5    | 6    | 6    | 6    | 6    | 6    | 11   |                      |
| 5          | 1    | 1    | 1    | 1    | 5    | 6    | 6    | 6    | 6    | 6    | 6    |                      |
| 1          | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |                      |
|            | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 背包大小             |

## LeetCode413-[等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

> 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。
>
> 例如，以下数列为等差数列:
>
> 1, 3, 5, 7, 9
> 7, 7, 7, 7
> 3, -1, -5, -9
> 以下数列不是等差数列。
>
> 1, 1, 2, 5, 7
>
>
> 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。
>
> 如果满足以下条件，则称子数组(P, Q)为等差数组：
>
> 元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。
>
> 函数要返回数组 A 中所有为等差数组的子数组个数。
>
>  
>
> 示例:
>
> A = [1, 2, 3, 4]
>
> 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
>

### 实现思路

1. 这题的特点是只要符合结果的数都必须增加放进去，而且每一个放进去的都是只能放一次。这就很符合01背包的定义了。通过分析可以知道:
   1. 对于[1,2,3]来说，加入4变成[1,2,3,4]时，增加了[2,3,4]和[1,2,3,4]
   2. 对于[1,2,3,4]来说，加入5变成[1,2,3,4,5]时，增加了[3,4,5]、[2,3,4,5]和[1,2,3,4,5]
   3. 这就是有规律的，如果是等差数列的时候，每增加一个数，等差数列增加的数量就比前一个等差数列增加的数量多一个
2. 边界条件：数组个数少于3时不组成等差数列，直接返回0即可

### 实现代码

```java
class Solution {
  public int numberOfArithmeticSlices(int[] A) {
    // 边界条件
    if (A == null || A.length < 3)
      return 0;

    // 使用数组记录加入第i个数时，等差数列增加的数量
    // tips：此处可以使用一个变量即可
    int[] dp = new int[A.length];
    int slice = A[1] - A[0];	// 计算前两个数的差值
    int sum = 0;	// 子数组的个数总和
    for (int i = 2; i < A.length; i++) {
      int tmp = A[i] - A[i-1];
      if (slice == tmp) {	// 当前两个数的差值等于前两个数的差值，组成等差数列
        dp[i] = dp[i-1] + 1;	// 第i个数新增的数组个数 = 第i-1新增的数组个数 + 1
        sum += dp[i];	// 子数组的个数 = 前i-1个数的数组个数总和 + 第i个数加入后新增的数组个数
      } else {
        dp[i] = 0;	// 当前两个数的差值与前两个数的差值不一致，从头开始计算
        slice = tmp;	// 更新差值
      }
    }
    return sum;
  }
}
```

### 示例

以数组[1,2,3,4,8,9,10]为例，对应的图表如下所示，最后的结果只需要计算最后一行的总和即可。

| 对应为最后一个数 | 1    | 2    | 3    | 4    | 8    | 9    | 10   |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 10               | 0    | 0    | 1    | 2    | 0    | 0    | 1    |
| 9                | 0    | 0    | 1    | 2    | 0    | 0    |      |
| 8                | 0    | 0    | 1    | 2    | 0    |      |      |
| 4                | 0    | 0    | 1    | 2    |      |      |      |
| 3                | 0    | 0    | 1    |      |      |      |      |
| 初始化           | 0    | 0    |      |      |      |      |      |

## LeetCode213-[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
>
> 示例 1:
>
> 输入: [2,3,2]
> 输出: 3
> 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
> 示例 2:
>
> 输入: [1,2,3,1]
> 输出: 4
> 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>      偷窃到的最高金额 = 1 + 3 = 4 。

### 解题思路

1. 由于这是一个环，意味着选择了第一个就不能选择最后一个，所以要分两种情况讨论：
   1. 从第一个开始偷，那第一个就必须选。代表第2、3个的价值总和都是S1。然后以第i个作为结尾的时候，第i个不能偷，第i个的最大价值总和为Max(第i-1个的价值Wi-1+第i-2个的价值总和Si-2，第i-1个的价值总和Si-1)
   2. 从第2个开始偷，那第一个的价值总和为0，第二个的价值总和S2=W2。最后一个是可以偷的，所以第i个的价值总和为Max(第i个的价值Wi+第i-1个的价值总和Si-1，第i-1个的价值总和)
2. 边界条件：
   1. 数组长度为0时直接返回0
   2. 数组长度为1时，直接返回数组中的数即可
   3. 数组长度为2时，直接返回数组中最大的那一个即可。因为第一种情况中

### 代码

```java
class Solution {
  public int rob(int[] nums) {
    // 边界条件
    if (nums == null || nums.length == 0) {
      return 0;
    }

    // 边界条件
    if (nums.length == 1) {
      return nums[0];
    }

		// 边界条件
    if (nums.length == 2) {
      return Math.max(nums[0], nums[1]);
    }
    
    int[] dp = new int[nums.length + 1];
    // 从第一个开始偷，由于偷了第一个，所以第二个不可能偷。
    // 当第三个为最后一个时，也不偷第三个
    dp[1] = nums[0];
    dp[2] = dp[1];
    dp[3] = dp[1];
    for (int i = 4; i <= nums.length ; i++) {
      dp[i] = Math.max(nums[i - 2] + dp[i - 2], dp[i - 1]);
    }
    int value = dp[nums.length];
    // 第一个不偷
    dp[1] = 0;
    for (int i = 2; i <= nums.length; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
    }
    return Math.max(dp[nums.length], value);
  }
}
```

### 示例

- 当数组为[4,1,2,7,5,3,1]时，从第一个开始偷的结果

| 对应的最后一个数 | 4    | 1    | 2    | 7            | 5             | 3              | 1               |
| ---------------- | ---- | ---- | ---- | ------------ | ------------- | -------------- | --------------- |
| 1                | 4    | 4    | 4    | 6            | 11            | 11             | max(3+11,11)=14 |
| 3                | 4    | 4    | 4    | 6            | 11            | max(5+6,11)=11 |                 |
| 5                | 4    | 4    | 4    | 6            | max(7+4,6)=11 |                |                 |
| 7                | 4    | 4    | 4    | max(2+4,4)=6 |               |                |                 |
| 初始化           | 4    | 4    | 4    |              |               |                |                 |

- 从第二个开始偷的结果

| 对应的最后一个数 | 4    | 1            | 2            | 7            | 5            | 3             | 1              |
| ---------------- | ---- | ------------ | ------------ | ------------ | ------------ | ------------- | -------------- |
| 1                | 0    | 1            | 2            | 8            | 8            | 11            | max(1+8,11)=11 |
| 3                | 0    | 1            | 2            | 8            | 8            | max(3+8,8)=11 |                |
| 5                | 0    | 1            | 2            | 8            | max(5+2,8)=8 |               |                |
| 7                | 0    | 1            | 2            | max(7+1,2)=8 |              |               |                |
| 2                | 0    | 1            | max(2+0,1)=2 |              |              |               |                |
| 1                | 0    | max(1+0,0)=1 |              |              |              |               |                |
| 初始化           | 0    |              |              |              |              |               |                |

最后结果只需要取两个表最后一个数的最大值，此处是Max(11, 14)=14。

参考：

- [崔添翼. 背包问题九讲 2.0 beta1.2, 2012-05-08](#)
- [LeetCode. China](https://leetcode-cn.com/)

